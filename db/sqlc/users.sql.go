// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package db

import (
	"context"
	"database/sql"
	"example/models"
	"fmt"
	"strings"

)

const createusers = `-- name: Createusers :exec
INSERT INTO users (username, first_name, last_name, pre_password, password, encrypted_passwrod, address,
phone_no, aadhaar_no, status, is_active) 
VALUES(? ,? ,? ,? ,? ,? ,? ,? ,? ,? ,?)
`
const createserviceprovider = `-- name: CreateuServiceProvider :exec
INSERT INTO service_provider (service_id , username, first_name, last_name, pre_password, password, encrypted_passwrod, address,
phone_no, aadhaar_no, status, is_active) 
VALUES(?,? ,? ,? ,? ,? ,? ,? ,? ,? ,? ,?)
`

type CreateusersParams struct {
	ServiceId         sql.NullInt64 `json:"service_id"`
	Username          sql.NullString `json:"username"`
	FirstName         sql.NullString `json:"first_name"`
	LastName          sql.NullString `json:"last_name"`
	PrePassword       sql.NullString `json:"pre_password"`
	Password          sql.NullString `json:"password"`
	EncryptedPasswrod sql.NullString `json:"encrypted_passwrod"`
	Address           sql.NullString `json:"address"`
	PhoneNo           sql.NullString `json:"phone_no"`
	AadhaarNo         sql.NullString `json:"aadhaar_no"`
	Status            sql.NullInt32  `json:"status"`
	IsActive          sql.NullInt32  `json:"is_active"`
}

func (q *Queries) Createusers(ctx context.Context, arg CreateusersParams,isUser int) (int64,error) {
	var sql string
	if isUser == 0{
			sql = createserviceprovider
	}else{
		sql = createusers
	}
	result, err := q.db.ExecContext(ctx, sql,
		arg.ServiceId,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.PrePassword,
		arg.Password,
		arg.EncryptedPasswrod,
		arg.Address,
		arg.PhoneNo,
		arg.AadhaarNo,
		arg.Status,
		arg.IsActive,
	)
	if err != nil{
		return 0,err
	}
	id,err:=result.LastInsertId()
	if err != nil{
		return 0,err
	}
	return id,err}


const deleteusersById = `-- name: DeleteusersById :exec
Delete FROM users where id = ?
`

func (q *Queries) DeleteusersById(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteusersById, id)
	return err
}

const getListusers = `-- name: GetListusers :many
SELECT id, username, first_name, last_name, pre_password, password, encrypted_passwrod, address, phone_no, aadhaar_no, status, is_active, created_date, updated_date, deleted_date FROM users LIMIT ? OFFSET ?
`



type GetListusersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetListusers(ctx context.Context, arg GetListusersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getListusers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.PrePassword,
			&i.Password,
			&i.EncryptedPasswrod,
			&i.Address,
			&i.PhoneNo,
			&i.AadhaarNo,
			&i.Status,
			&i.IsActive,
			&i.CreatedDate,
			&i.UpdatedDate,
			&i.DeletedDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpdatedAccount = `-- name: GetUpdatedAccount :one
SELECT id, username, first_name, last_name, pre_password, password, encrypted_passwrod, address, phone_no, aadhaar_no, status, is_active, created_date, updated_date, deleted_date FROM users WHERE id = ?
`

func (q *Queries) GetUpdatedAccount(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUpdatedAccount, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.PrePassword,
		&i.Password,
		&i.EncryptedPasswrod,
		&i.Address,
		&i.PhoneNo,
		&i.AadhaarNo,
		&i.Status,
		&i.IsActive,
		&i.CreatedDate,
		&i.UpdatedDate,
		&i.DeletedDate,
	)
	return i, err
}

const getusers = `-- name: Getusers :one
SELECT id, username, first_name, last_name, pre_password, password, encrypted_passwrod, address, phone_no, aadhaar_no,lat,lon ,status, is_active, created_date, updated_date, deleted_date FROM users where id = ? OR username = ? OR phone_no = ?
`
const getserviceporvider = `-- name: Getserviceporvider :one
SELECT id, username, first_name, last_name, pre_password, password, encrypted_passwrod, address, phone_no, aadhaar_no,lat,lon ,status, is_active, created_date, updated_date, deleted_date FROM service_provider where id = ? OR username = ? OR phone_no = ?
`
type GetusersParams struct {
	ID       int32          `json:"id"`
	Username sql.NullString `json:"username"`
	PhoneNo  sql.NullString `json:"phone_no"`
	IsUser   int64  `json:"is_user"`
}


func (q *Queries) Getusers(ctx context.Context, arg GetusersParams) (User, error) {
	var sql string
	if arg.IsUser==0{
		sql=getserviceporvider
	}else{
		sql=getusers
	}
	row := q.db.QueryRowContext(ctx, sql, arg.ID, arg.Username, arg.PhoneNo)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.FirstName,
		&i.LastName,
		&i.PrePassword,
		&i.Password,
		&i.EncryptedPasswrod,
		&i.Address,
		&i.PhoneNo,
		&i.AadhaarNo,
		&i.Lat,
		&i.Lon,
		&i.Status,
		&i.IsActive,
		&i.CreatedDate,
		&i.UpdatedDate,
		&i.DeletedDate,
	)
	return i, err
}

const updateusers = `-- name: Updateusers :exec
UPDATE users SET username = ? , first_name = ? , last_name = ? , pre_password = ? , 
password = ?,encrypted_passwrod = ? , phone_no = ? WHERE username =?
`
const updateserviceprovider = `-- name: Updateusers :exec
UPDATE service_provider SET username = ? , first_name = ? , last_name = ? , pre_password = ? , 
password = ?,encrypted_passwrod = ? , phone_no = ? WHERE username =?
`
type UpdateusersParams struct {
	Username          sql.NullString `json:"username"`
	FirstName         sql.NullString `json:"first_name"`
	LastName          sql.NullString `json:"last_name"`
	PrePassword       sql.NullString `json:"pre_password"`
	Password          sql.NullString `json:"password"`
	EncryptedPasswrod sql.NullString `json:"encrypted_passwrod"`
	PhoneNo           sql.NullString `json:"phone_no"`
	Username_2        sql.NullString `json:"username_2"`
	IsUser   int64  `json:"is_user"`
}

func (q *Queries) Updateusers(ctx context.Context, arg UpdateusersParams) (int64,error) {
	var sql string
	if arg.IsUser==0{
		sql =updateserviceprovider
	}else{
		sql =updateusers
	}
	result, err := q.db.ExecContext(ctx, sql,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.PrePassword,
		arg.Password,
		arg.EncryptedPasswrod,
		arg.PhoneNo,
		arg.Username_2,
	)
	if err != nil{
		return 0,nil
	}
	id,err:=result.LastInsertId()
	if err != nil{
		return 0,nil
	}
	return id,err
}

const getAvailability = `-- name: GetAvailability :many
SELECT id, service_id,service_provider_id FROM type_availability where date IN (?) and time like ? and service_id = ? and is_active = ? and temp_block_schedule = ? and  schedule_confirmed = ? 
`

func (q *Queries) GetTypeAvailability(ctx context.Context,availability models.DateTime) ([]models.TypeAvailability, error) {

	// Dynamically create placeholders for the dates
	datePlaceholders := make([]string, len(availability.Date))
	queryParams := make([]interface{}, 0, len(availability.Date)+5) // 5 other parameters
	for i, date := range availability.Date {
		datePlaceholders[i] = "?"
		queryParams = append(queryParams, date)
	}

	// Add the remaining query parameters
	time:=strings.Split(availability.Time," ")
	queryParams = append(queryParams, "%"+time[1], availability.ServiceID, 1, 0, 0)
	// Query with dynamic IN clause
	query := fmt.Sprintf(`
		SELECT id, service_id, service_provider_id ,date,time
		FROM type_availability
		WHERE date IN (%s) 
		AND time LIKE ?
		AND service_id = ? 
		AND is_active = ? 
		AND temp_block_schedule = ? 
		AND schedule_confirmed = ?`,
		strings.Join(datePlaceholders, ","),
	)
	rows, err := q.db.QueryContext(ctx,query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []models.TypeAvailability
	for rows.Next() {
		var i models.TypeAvailability
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.ServiceProviderID,
			&i.Date,
			&i.Time,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
const getListservices = `-- name: GetListService :many
SELECT id, service_type FROM services where is_active = ?
`

func (q *Queries) GetListService(ctx context.Context) ([]models.Service, error) {
	rows, err := q.db.QueryContext(ctx, getListservices , 1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []models.Service
	for rows.Next() {
		var i models.Service
		if err := rows.Scan(
			&i.ID,
			&i.ServiceType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListservicestype = `-- name: GetListService :many
SELECT id ,service_id, username,lat,lon FROM service_provider where service_id = ? AND is_active = ? 
`
func (q *Queries) GetListServiceType(ctx context.Context,id int32) ([]models.ServiceProvider, error) {
	rows, err := q.db.QueryContext(ctx, getListservicestype, id, 1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []models.ServiceProvider
	for rows.Next() {
		var i models.ServiceProvider
		if err := rows.Scan(
			&i.ServiceProviderID,
			&i.ServiceID,
			&i.Username,
			&i.Lat,
			&i.Lon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}


const getAppointment = `-- name: GetAvailability :many
SELECT appointermnts.id,appointermnts.user_id,appointermnts.upcoming,appointermnts.completed,appointermnts.cancelled, 
		service_provider.username ,service_provider.phone_no , 
		services.service_type,
		type_availability.date,type_availability.time 
FROM service_pro.appointermnts appointermnts, 
	service_pro.service_provider service_provider, 
	service_pro.services services, 
	service_pro.type_availability type_availability 
	WHERE  	
type_availability.service_provider_id = service_provider.id AND type_availability.service_id = services.id 	AND appointermnts.type_availability_id = type_availability.id and appointermnts.user_id =? and appointermnts.status = ?;
`

func (q *Queries) GetAppointment(ctx context.Context,user User) ([]models.Appointment, error) {
	rows, err := q.db.QueryContext(ctx, getAppointment,user.ID, 1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []models.Appointment
	for rows.Next() {
		var i models.Appointment
		if err := rows.Scan(
			&i.ID,
			&i.UserId,
			&i.Upcoming,
			&i.Completed,
			&i.Cancelled,
			&i.Username,
			&i.PhoneNo,
			&i.ServiceType,
			&i.Date,
			&i.Time,

		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListServiceTypeByDate = `-- name: GetListService :many
SELECT 
service_provider.service_id,service_provider.username,service_provider.phone_no,service_provider.lat,service_provider.lon , 
type_availability.service_provider_id,type_availability.date,type_availability.time FROM service_pro.service_provider service_provider, service_pro.type_availability
type_availability WHERE type_availability.service_provider_id = service_provider.id and type_availability.service_id = ? and 
type_availability.date = ?;

`
func (q *Queries) GetListServiceTypeByDate(ctx context.Context,k models.TypeAvailability) ([]models.ServiceProvider, error) {
	rows, err := q.db.QueryContext(ctx, getListServiceTypeByDate, k.ServiceID,k.Date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []models.ServiceProvider
	for rows.Next() {
		var i models.ServiceProvider
		if err := rows.Scan(
			&i.ServiceID,
			&i.Username,
			&i.Phone,
			&i.Lat,
			&i.Lon,
			&i.ServiceProviderID,
			&i.Date,
			&i.Time,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}